<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChengUU</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/ChengUU/"/>
  <updated>2025-12-07T17:15:03.078Z</updated>
  <id>https://github.com/ChengUU/</id>
  
  <author>
    <name>ChengUU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速幂模运算原理详解</title>
    <link href="https://github.com/ChengUU/2018/12/07/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E8%BF%90%E7%AE%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/ChengUU/2018/12/07/快速幂模运算原理详解/</id>
    <published>2018-12-07T12:59:22.000Z</published>
    <updated>2025-12-07T17:15:03.078Z</updated>
    
    <content type="html"><![CDATA[<p>$$ a^(p-1)&equniv;1 mod p $$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$$ a^(p-1)&amp;equniv;1 mod p $$&lt;/p&gt;

      
    
    </summary>
    
      <category term="基础算法" scheme="https://github.com/ChengUU/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="编程技巧" scheme="https://github.com/ChengUU/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
      <category term="信息安全基础" scheme="https://github.com/ChengUU/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
      <category term="加密解密" scheme="https://github.com/ChengUU/tags/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java实现十六进制编码器</title>
    <link href="https://github.com/ChengUU/2018/11/29/Java%E5%AE%9E%E7%8E%B0%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    <id>https://github.com/ChengUU/2018/11/29/Java实现十六进制编码器/</id>
    <published>2018-11-29T12:05:23.000Z</published>
    <updated>2025-12-08T05:26:34.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p></p><p>以前也处理过将数字转换为16进制的问题，虽然现在已不记得当时的处理流程了，唯一留下的印象便是，复杂、不满意、可扩展性差、不够灵活……<br>由于项目需要打算自己实现CSPRNG（Cryptographically Secure Pseudo-Random Number Generator, 伪随机数产生器）。查阅相关资料后发现Java提供了相关的类(SecureRandom类)，并且非常好用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom secureRandom=new SecureRandom();</span><br><span class="line">byte[] bytes=new byte[32];</span><br><span class="line">secureRandom.nextBytes(bytes);</span><br></pre></td></tr></table></figure></p><p></p><p>但是生成的随机数结果是一个字节数组，这用起来不是很方便，于是就想着将其转换为16进制字符串。正如大家所知道的那样，Java写的很多工具库都是开源的，查阅相关资料后找到了一种较为简单且有效的实现(<strong><em><a href="https://github.com/bcgit/bc-java.git">开源工具库</a></em></strong>),该实现共涉及3个类: Strings-String类对应的工具类；HexEncoder-提供16进制编码具体实现，包括编码和解码；Hex通过持有HexEncoder类实例对象提供HexEncoder相关功能（—适配器模式的两种实现—）: 对字节数组进行编码，对十六进制字符串进行解码。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>字节与16进制数之间的对应关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 byte = 8 bits</span><br><span class="line">4 bits = 一位16进制数</span><br></pre></td></tr></table></figure></p><ol><li>16进制编码-字节数组转16进制<br>根据上述对应关系，可以对字节数组依次进行处理，具体的处理方法： 通过移位运算依次处理该字节的左边四位和右边四位并查找编码映射表取出相应的16进制字符，最后将其放入字节数组输出流。<br><strong>编码映射表 EncodingTable</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final byte[] encodingTable = new byte[]&#123;//digital number map to character</span><br><span class="line">    (byte) &apos;0&apos;, (byte) &apos;1&apos;, (byte) &apos;2&apos;, (byte) &apos;3&apos;, (byte) &apos;4&apos;, (byte) &apos;5&apos;, (byte) &apos;6&apos;, (byte) &apos;7&apos;,</span><br><span class="line">    (byte) &apos;8&apos;, (byte) &apos;9&apos;, (byte) &apos;a&apos;, (byte) &apos;b&apos;, (byte) &apos;c&apos;, (byte) &apos;d&apos;, (byte) &apos;e&apos;, (byte) &apos;f&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>使用编码映射表可以提高编码速度，从而使进制转的效率得到较大的提升。字节数组转16进制数组的核心实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * encoding byte element to hexadecimal via shift operation.</span><br><span class="line"> *</span><br><span class="line"> * @param data   byte array</span><br><span class="line"> * @param offset the start position</span><br><span class="line"> * @param length the length of data to be processed.</span><br><span class="line"> * @param os     the result stream.</span><br><span class="line"> * @return the length of result.</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public int encode(byte[] data, int offset, int length, OutputStream os) throws IOException &#123;</span><br><span class="line">for (int i = offset; i &lt; offset + length; i++) &#123;</span><br><span class="line">    int val = data[i] &amp; 0xff;</span><br><span class="line">    // &gt;&gt;&gt;: unsigned right bit shift</span><br><span class="line">    os.write(encodingTable[val &gt;&gt;&gt; 4]);</span><br><span class="line">    os.write(encodingTable[val &amp; 0x0f]);</span><br><span class="line">&#125;</span><br><span class="line">// Each 4 bits corresponds to a hexadecimal number and one byte is 8 bits,</span><br><span class="line">// so the length of conversion result is 2 times original data length.</span><br><span class="line">return length * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>16进制字符串转字节数组<br>16进制字符串亦可以是字节数组，字符串中每一个字符占1字节，字节数组中每一个元素也占一个字节，它们在更小度量上是一样的——8 bits，原则上每一位元素均为16进制字符，也就是说每一个元素或字符仅有其右四位为有效位(左边四位默认值为全零)。在将16进制字符串转换为字节数组的时利用位运算可以将相邻的两位16进制数存至一个字节中： 将前一个字符或元素向左移4位后再与另一个字符或元素进行或运算，这样就将其存至1个字节中。16进制字符串转字节数组核心实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * decoding hexadecimal string to digital number.</span><br><span class="line"> * @param data hexadecimal string.</span><br><span class="line"> * @param os the result stream.</span><br><span class="line"> * @return the length of result stream.</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public int decode(String data,OutputStream os)throws IOException&#123;</span><br><span class="line">    byte b1,b2;</span><br><span class="line">    int length=0;</span><br><span class="line">    int offset=0;</span><br><span class="line">    int end=data.length();</span><br><span class="line">    while(end&gt;offset)&#123;</span><br><span class="line">        char ch=data.charAt(end-1);</span><br><span class="line">        if(!ignore(ch)) break;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=offset;</span><br><span class="line">    while(i&lt;end)&#123;</span><br><span class="line">        char ch=data.charAt(i);</span><br><span class="line">        while(i&lt;end&amp;&amp;ignore(ch)) &#123;</span><br><span class="line">            ch=data.charAt(++i);</span><br><span class="line">        &#125;</span><br><span class="line">        b1=decodingTable[data.charAt(i++)];</span><br><span class="line">        ch=data.charAt(i);</span><br><span class="line">        while(i&lt;end&amp;&amp;ignore(ch))&#123;</span><br><span class="line">            ch=data.charAt(++i);</span><br><span class="line">        &#125;</span><br><span class="line">        b2=decodingTable[data.charAt(i++)];</span><br><span class="line"></span><br><span class="line">        if((b1|b2)&lt;0)&#123;</span><br><span class="line">            throw new IOException(&quot;invalid character encounter in Hex data&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        os.write((b1&lt;&lt;4)|b2);</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><em>需要注意的是</em>该十六进制字符串应该为长度是偶数的字符串，否则在转换过程中将会出现不可处理的错误，由于待转换的字符串由使用者传入，所以在并未进行额外的处理。</p><ol start="3"><li><p>Hex工具类<br>该工具类持有一个类常量对象encoder，并提供类静态方法使用HexEncoder编解码功能，通过该来对HexEncoder类进行了适配，该类主要提供的方法包括： toHexString(byte[] data),decode(String data).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * encoding byte array.</span><br><span class="line"> * @param data byte array to be encoded.</span><br><span class="line"> * @return Hexadecimal String.</span><br><span class="line"> */</span><br><span class="line">public static String toHexString(byte[] data)&#123;</span><br><span class="line">    return toHexString(data,0,data.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * encodeing byte array.</span><br><span class="line"> * @param data byte array to be encoded.</span><br><span class="line"> * @param offset the start of encoding element.</span><br><span class="line"> * @param length the length of element to be encoded.</span><br><span class="line"> * @return Hexadecimal String.</span><br><span class="line"> */</span><br><span class="line">public static String toHexString(byte[] data,int offset,int  length)&#123;</span><br><span class="line">    byte[] encoded=encode(data,offset,length);</span><br><span class="line">    return Strings.fromByteArray(encoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * encode byte array to  be hexadecimal character byte array.</span><br><span class="line"> * @param data the byte array to be encoded.</span><br><span class="line"> * @param offset the start of encoding position.</span><br><span class="line"> * @param length the length of element to be encoded.</span><br><span class="line"> * @return hexadecimal character byte array.</span><br><span class="line"> */</span><br><span class="line">public static byte[] encode(byte[] data,int offset,int length)&#123;</span><br><span class="line">    ByteArrayOutputStream baos=new ByteArrayOutputStream();</span><br><span class="line">    try&#123;</span><br><span class="line">        encoder.encode(data,offset,length,baos);</span><br><span class="line">    &#125;catch(IOException e)&#123;</span><br><span class="line">        throw new EncoderException(&quot;exception encoding Hex string: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    return baos.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * decoding hex string, whitespace will be ignored.</span><br><span class="line"> * @param data Hex String.</span><br><span class="line"> * @return decoding result.</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static byte[] decode(String data)throws IOException&#123;</span><br><span class="line">    ByteArrayOutputStream baos=new ByteArrayOutputStream();</span><br><span class="line">    decode(data,baos);</span><br><span class="line">    return baos.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * decoding Hex String.</span><br><span class="line"> * @param data Hex String</span><br><span class="line"> * @param os OutputStream Object.</span><br><span class="line"> * @return the length of decoding producing byte.</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static int decode(String data,OutputStream os)throws IOException&#123;</span><br><span class="line">    return encoder.decode(data,os);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Strings类实现<br>Strings类为String类对应的工具类，该类在此提供了将字节数组转换成字符数组功能和将字节数组转换为字符串功能。<br>具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * converting byte array to string.</span><br><span class="line"> *</span><br><span class="line"> * @param encoded the byte array to be processed.</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static String fromByteArray(byte[] encoded) &#123;</span><br><span class="line">    return new String(asCharArray(encoded));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * converting byte array to char array.</span><br><span class="line"> *</span><br><span class="line"> * @param encoded the byte array to be processed.</span><br><span class="line"> * @return char array.</span><br><span class="line"> */</span><br><span class="line">private static char[] asCharArray(byte[] encoded) &#123;</span><br><span class="line">    char[] chars = new char[encoded.length];</span><br><span class="line">    for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">        chars[i] = (char) (encoded[i] &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">    return chars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试<br>主要针对Java内置加密安全的伪随机数生成结果进行编解码，对常见字符串进行编解码，对常见数字进行编解码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import util.encoders.Hex;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class CsprngTest &#123;</span><br><span class="line">    public static void main(String[] args)throws IOException &#123;</span><br><span class="line">        SecureRandom secureRandom=new SecureRandom();</span><br><span class="line">        byte[] bytes=new byte[32];</span><br><span class="line">        secureRandom.nextBytes(bytes);</span><br><span class="line">        String str= Hex.toHexString(bytes);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        byte[] decodeBytes=Hex.decode(str);</span><br><span class="line">        boolean flag=Arrays.equals(bytes,decodeBytes);</span><br><span class="line">        System.out.println(&quot;equals: &quot;+flag);</span><br><span class="line"></span><br><span class="line">        System.out.println(Hex.toHexString(&quot;0123456789abcdef&quot;.getBytes()));                    //测试将字符串转化为16进制</span><br><span class="line">        System.out.println(new String(Hex.decode(&quot;30313233343536373839616263646566&quot;)));   //反向测试将16进制转化为字符串</span><br><span class="line"></span><br><span class="line">        int integer=1000;</span><br><span class="line">        ByteArrayOutputStream baos=new ByteArrayOutputStream();</span><br><span class="line">        baos.write(integer);</span><br><span class="line">        bytes=baos.toByteArray();</span><br><span class="line">        System.out.println(&quot;bytes lngth: &quot;+bytes.length);</span><br><span class="line">        str=Hex.toHexString(bytes);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="程序执行结果"><a href="#程序执行结果" class="headerlink" title="程序执行结果"></a>程序执行结果</h3><p><img src="/images/20181129221429.png" alt="测试结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以前也处理过将数字转换为16进制的问题，虽然现在已不记得当时的处理流程了，唯一留下的印象便是，复杂、不满意、可扩展性差、不够灵
      
    
    </summary>
    
      <category term="Java编程" scheme="https://github.com/ChengUU/categories/Java%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进制转换" scheme="https://github.com/ChengUU/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="编码器" scheme="https://github.com/ChengUU/tags/%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统中安装JDK</title>
    <link href="https://github.com/ChengUU/2018/11/21/Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%89%E8%A3%85JDK/"/>
    <id>https://github.com/ChengUU/2018/11/21/Linux系统中安装JDK/</id>
    <published>2018-11-21T13:17:08.000Z</published>
    <updated>2025-12-07T17:15:03.069Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载合适的JDK安装包</li><li><p>创建Java JDK安装位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /opt/java</span><br></pre></td></tr></table></figure></li><li><p>解压安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zvx -f jdk*.tar.gz /opt/java/</span><br></pre></td></tr></table></figure></li><li><p>打开用户环境变量配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set JAVA_HOME=/usr/java/jdk1.8.0_141</span><br><span class="line">export JAVA_HOME</span><br><span class="line">set JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export JRE_HOME</span><br><span class="line">set JAVA_BIN=$JAVA_HOME/bin</span><br><span class="line">export JAVA_BIN</span><br><span class="line">set JAVA_LIB=$JAVA_HOME/lib</span><br><span class="line">export JAVA_LIB</span><br><span class="line"></span><br><span class="line">set CLASSPATH=.:$JAVA_LIB/tools.jar:$JAVA_LIB/dt.jar</span><br><span class="line">export CLASSPATH</span><br><span class="line">set PATH=$JAVA_BIN:$JRE_HOME/bin:$PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></li><li><p>安装和注册java，javac</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/java java /opt/java/jdk*/bin/java 1</span><br><span class="line">update-alternatives --install /usr/bin/javac javac /opt/java/jdk*/bin/javac 1</span><br><span class="line">update-alternatives --set java /opt/java/jdk*/bin/java </span><br><span class="line">update-alternatives --set javac /opt/java/jdk*/bin/javac</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/JDK安装和注册.png" alt="JDK安装和注册"></p><ol start="7"><li>选择java，javac<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config java</span><br><span class="line">update-alternatives --config javac</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/设置系统JDK环境.png" alt="设置系统JDK环境"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;下载合适的JDK安装包&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建Java JDK安装位置&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="Linux|Ubuntu" scheme="https://github.com/ChengUU/categories/Linux-Ubuntu/"/>
    
    
      <category term="JDK" scheme="https://github.com/ChengUU/tags/JDK/"/>
    
      <category term="JAVA" scheme="https://github.com/ChengUU/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>git放弃本地修改,强制覆盖本地代码</title>
    <link href="https://github.com/ChengUU/2018/11/21/git%E6%94%BE%E5%BC%83%E6%9C%AC%E5%9C%B0%E4%BF%AE%E6%94%B9-%E5%BC%BA%E5%88%B6%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/ChengUU/2018/11/21/git放弃本地修改-强制覆盖本地代码/</id>
    <published>2018-11-21T12:18:08.000Z</published>
    <updated>2025-12-08T05:23:52.643Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Git的过程中，有些时候我们只想要git服务器中的最新版本的项目，对于本地的项目中修改不做任何理会，就需要用到Git pull的强制覆盖，具体代码如下：<br><img src="/images/psb.png" alt="命令行"></p><p>git pull强制覆盖本地文件在自动化部署项目中很有作用</p><ul><li><p>放弃未缓存的文件修改<br>Git未缓存文件,即为未使用<code>git add</code>命令的修改:<br><img src="/images/20181203171448.png" alt="未缓存文件-图"></p><ul><li><p>指定文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;filename&gt;</span><br></pre></td></tr></table></figure></li><li><p>所有未缓存文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure></li></ul></li><li><p>放弃已缓存文件<br>Git使用<code>git add</code>命令缓存文件:<br><img src="/images/20181203171904.png" alt="Git缓存文件"></p><ul><li><p>指定文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure></li><li><p>所有已缓存文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD .</span><br></pre></td></tr></table></figure></li></ul></li><li><p>放弃待push文件<br>使用<code>git commit</code>命令提交更改后,使用<code>git reset</code>命令放弃提交:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log  # 查看日志</span><br><span class="line">git reset --hard  c3ad83eae52d3fcecab82eefce2367ca42db2afd # 回到上一次提交</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/20181203172457.png" alt="放弃待push文件"><br><img src="/images/20181203172747.png" alt="放弃待push文件"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Git的过程中，有些时候我们只想要git服务器中的最新版本的项目，对于本地的项目中修改不做任何理会，就需要用到Git pull的强制覆盖，具体代码如下：&lt;br&gt;&lt;img src=&quot;/images/psb.png&quot; alt=&quot;命令行&quot;&gt;&lt;/p&gt;
&lt;p&gt;git pull强
      
    
    </summary>
    
      <category term="Git" scheme="https://github.com/ChengUU/categories/Git/"/>
    
    
      <category term="Git版本管理" scheme="https://github.com/ChengUU/tags/Git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Windows端口映射配置</title>
    <link href="https://github.com/ChengUU/2018/11/21/Windows%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://github.com/ChengUU/2018/11/21/Windows端口映射配置/</id>
    <published>2018-11-21T10:56:17.000Z</published>
    <updated>2025-12-07T17:15:03.069Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>端口映射配置命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=192.168.1.166 listenport=11122 connectaddress=192.168.1.128 connectport=22</span><br><span class="line"># 或者</span><br><span class="line">netsh interface portproxy add v4tov4 listenport=11122 connectaddress=192.168.1.128 connectport=22</span><br></pre></td></tr></table></figure></li><li><p>查看端口映射列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy show v4tov4</span><br></pre></td></tr></table></figure></li><li><p>删除指定端口映射项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 listenaddress=192.168.1.166 listenport=11122</span><br><span class="line">＃或者</span><br><span class="line">netsh interface portproxy delete v4tov4 listenport=11122</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;端口映射配置命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://github.com/ChengUU/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="内网穿透" scheme="https://github.com/ChengUU/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>VMware虚拟机固定IP设置</title>
    <link href="https://github.com/ChengUU/2018/11/21/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BA%E5%AE%9AIP%E8%AE%BE%E7%BD%AE/"/>
    <id>https://github.com/ChengUU/2018/11/21/VMware虚拟机固定IP设置/</id>
    <published>2018-11-21T10:55:54.000Z</published>
    <updated>2025-12-07T17:15:03.069Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>修改网络适配器名称<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/default/grub</span><br><span class="line"></span><br><span class="line">修改内容：</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;net.ifnames=0 biosdevname=0&quot;</span><br><span class="line"></span><br><span class="line">sudo update-grub</span><br><span class="line"></span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></li><li><p>固定IP地址配置<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/network/interfaces</span><br><span class="line">修改内容:</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.128</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">dns-nameserver 192.168.1.1</span><br><span class="line"></span><br><span class="line">sudo /etc/init.d/networking restart</span><br><span class="line">sudo service networking restart</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改网络适配器名称&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/ChengUU/categories/Linux/"/>
    
    
      <category term="VMware虚拟机" scheme="https://github.com/ChengUU/tags/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Sublime-Text3安装激活</title>
    <link href="https://github.com/ChengUU/2018/11/21/Sublime-Text3%E5%AE%89%E8%A3%85%E6%BF%80%E6%B4%BB/"/>
    <id>https://github.com/ChengUU/2018/11/21/Sublime-Text3安装激活/</id>
    <published>2018-11-21T10:55:36.000Z</published>
    <updated>2025-12-08T05:24:24.875Z</updated>
    
    <content type="html"><![CDATA[<p>Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。下面将介绍如何下载Sublime- Text3安装包并激活详细步骤,<strong>请支持正版软件</strong>.</p><ol><li><p>Sublime Text3可以通过下载安装包直接安装,由于最新版本获取免费注册码困难,所以我们退而求其次,安装旧版本以满足我们的需要,安装下载地址格式: <a href="https://download.sublimetext.com/sublime-text_build-版本号_amd64.deb" target="_blank" rel="noopener">https://download.sublimetext.com/sublime-text_build-版本号_amd64.deb</a>, 例如:<a href="https://download.sublimetext.com/sublime-text_build-3143_amd64.deb" target="_blank" rel="noopener">Sublime-text_build-3143</a></p></li><li><p>通过以上方式下载安装包后双击即可安装,博主安装的版本为Sublime-text_build-3143<br>通过百度找到以下可使用的注册码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">—— BEGIN LICENSE ——  </span><br><span class="line">TwitterInc  </span><br><span class="line">200 User License  </span><br><span class="line">EA7E-890007  </span><br><span class="line">1D77F72E 390CDD93 4DCBA022 FAF60790  </span><br><span class="line">61AA12C0 A37081C5 D0316412 4584D136  </span><br><span class="line">94D7F7D4 95BC8C1C 527DA828 560BB037  </span><br><span class="line">D1EDDD8C AE7B379F 50C9D69D B35179EF  </span><br><span class="line">2FE898C4 8E4277A8 555CE714 E1FB0E43  </span><br><span class="line">D5D52613 C3D12E98 BC49967F 7652EED2  </span><br><span class="line">9D2D2E61 67610860 6D338B72 5CF95C69  </span><br><span class="line">E36B85CC 84991F19 7575D828 470A92AB  </span><br><span class="line">—— END LICENSE ——</span><br></pre></td></tr></table></figure></li><li><p>通过该注册码激活后可能会出现,注册码失效的情况,原因是该软件在线服务器会在线验证该激活码的有效性,所以可以通过阻止在线验证信息的传输间接实现软件破解.修改主机hosts文件,添加如下域名解析信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Sublime Text3</span><br><span class="line">127.0.0.1 license.sublimehq.com</span><br><span class="line">127.0.0.1 45.55.255.55</span><br><span class="line">127.0.0.1 45.55.41.223</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/20180505164219.png" alt="详细配置"></p><ol start="4"><li>修改软件更新信息’Preference-&gt;settings-User’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;font_size&quot;: 12,</span><br><span class="line">&quot;ignored_packages&quot;:</span><br><span class="line">[</span><br><span class="line">&quot;Vintage&quot;</span><br><span class="line">],</span><br><span class="line">&quot;update_check&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/20180505164043.png" alt="详细配置"></p><p><strong>不要忘记每行结尾的逗号</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。下面将介绍如何下载Sublime- Text3安装包并激活详细步骤,&lt;strong&gt;请支持正版软件&lt;/strong&gt;.&lt;/p&gt;
&lt;ol
      
    
    </summary>
    
      <category term="开发工具" scheme="https://github.com/ChengUU/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="软件安装激活" scheme="https://github.com/ChengUU/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%BF%80%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>DES算法原理详解及实现</title>
    <link href="https://github.com/ChengUU/2018/11/21/DES%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://github.com/ChengUU/2018/11/21/DES算法原理详解及实现/</id>
    <published>2018-11-21T10:55:17.000Z</published>
    <updated>2025-12-08T05:22:57.710Z</updated>
    
    <content type="html"><![CDATA[<p>使用最广泛的加密体制是数据加密标准(Data　Encryption Standard)，它于1972年被美国国家标准局(National Bureau of Standard, NBS)，即现在的国家标准和技术协会(National Institute of Standard and Technology, NIST)采纳为联邦信息处理标准。DES是对称加密算法里面常见的一种，是一种使用密钥加密的块算法，密钥长度为64位(bits)，超出长度部分的密钥将会被截取丢弃。所谓对称加密，即加密和解密使用的密钥相同。对称性加密一般会按照固定长度，把待加密字符串分成块，不足一块的部分使用特殊字符填充。常见的加密模式有ECB,CBC,CTR,OFB,CFB,NCFB,NOFB。DES算法流程图如下：<br><br><img src="/images/DES算法流程图.png" alt="DES算法流程图"></p><h1 id="DES加密"><a href="#DES加密" class="headerlink" title="DES加密"></a>DES加密</h1><p>DES加密算法主要分为两部分和三个阶段，子密钥产生部分和左右数据交换部分，明文会经过如下三个阶段的处理，首先初始数据通过置换进行重新排列，然后通过相同的函数作用以及进行置换和代替处理，最后第１６轮输出的６４位数据进行左右互换，通过初始置换的逆置换得到最终的密文。</p><h2 id="子密钥产生"><a href="#子密钥产生" class="headerlink" title="子密钥产生"></a>子密钥产生</h2><p>初始密钥通过置换选择表PC1，将64位密钥减少至56位，同时将56位密钥分成C0、D0两部分，C0和D0都是28位。将C0、D0向左循环位移指定次数得到C1、D1，然后将二者进行拼接，再经过置换选择表PC2得到最终的48位子密钥。<br>迭代加密过程中，每一轮循环位移的次数不同(16轮)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//循环位移次数</span><br><span class="line">int DISPLACEMENT_TURNS[]=&#123;1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1&#125;;</span><br></pre></td></tr></table></figure></p><p>置换选择表PC1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//置换选择表１</span><br><span class="line">int PC_1[]=&#123;57,49,41,33,25,17,9,1,</span><br><span class="line">                    58,50,42,34,26,18,10,2,</span><br><span class="line">                    59,51,43,35,27,19,11,3,</span><br><span class="line">                    60,52,44,36,63,55,47,39,</span><br><span class="line">                    31,23,15,7,62,54,46,38,</span><br><span class="line">                    30,22,14,6,61,53,45,37,</span><br><span class="line">                    29,21,13,5,28,20,12,4 &#125;;</span><br></pre></td></tr></table></figure></p><p>置换选择表PC2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//置换选择表２</span><br><span class="line">int PC_2[]=&#123;14,17,11,24,1,5,</span><br><span class="line">                    3,28,15,6,21,10,</span><br><span class="line">                    23,19,12,4,26,8,</span><br><span class="line">                    16,7,27,20,13,2,</span><br><span class="line">                    41,52,31,37,47,55,</span><br><span class="line">                    30,40,51,45,33,48,</span><br><span class="line">                    44,49,39,56,34,53,</span><br><span class="line">                    46,42,50,36,29,32 &#125;;</span><br></pre></td></tr></table></figure></p><p><strong>子密钥产生核心代码</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//子密钥产生</span><br><span class="line">int* generateSubKey(int key[],int turns)&#123;</span><br><span class="line">    int* subKey=new int[PC_1_LENGTH];</span><br><span class="line">    if(1==turns)&#123;//第１轮</span><br><span class="line">        //置换选择表PC1</span><br><span class="line">        int* tmp=repace_op(key,PC_1,PC_1_LENGTH);</span><br><span class="line">        //分为左右两部分</span><br><span class="line">        for(int i=0;i&lt;PC_HALF_LENGTH;i++)&#123;</span><br><span class="line">            //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i+PC_HALF_LENGTH&lt;&lt;endl;</span><br><span class="line">            C[i]=tmp[i];</span><br><span class="line">            D[i]=tmp[i+PC_HALF_LENGTH];</span><br><span class="line">            //cout&lt;&lt;tmp[i+PC_HALF_LENGTH]&lt;&lt;&quot; &quot;&lt;&lt;D[i+PC_HALF_LENGTH]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //将左右两部分向左进行循环位移</span><br><span class="line">        C=leftCycle(C,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);</span><br><span class="line">        D=leftCycle(D,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);</span><br><span class="line">        //将左右两部分进行拼接</span><br><span class="line">        for(int i=0;i&lt;PC_HALF_LENGTH;i++)&#123;</span><br><span class="line">            subKey[i]=C[i];</span><br><span class="line">            subKey[i+PC_HALF_LENGTH]=D[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //通过置换选择表PC2产生最终密钥</span><br><span class="line">        subKey=repace_op(subKey,PC_2,PC_2_LENGTH);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //将Ci-1、Di-1向左进行循环位移得到Ci、Di</span><br><span class="line">        C=leftCycle(C,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);</span><br><span class="line">        D=leftCycle(D,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);</span><br><span class="line">        //将Ci、Di进行拼接</span><br><span class="line">        for(int i=0;i&lt;PC_HALF_LENGTH;i++)&#123;</span><br><span class="line">            subKey[i]=C[i];</span><br><span class="line">            subKey[i+PC_HALF_LENGTH]=D[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //通过置换选择表PC2产生最终密钥</span><br><span class="line">        subKey=repace_op(subKey,PC_2,PC_2_LENGTH);</span><br><span class="line">    &#125;</span><br><span class="line">    return subKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="进行块加密"><a href="#进行块加密" class="headerlink" title="进行块加密"></a>进行块加密</h2><p>对64位原始数据通过IP表进行重新排列，将重新排列的数据分为左右两部分L、R（二者均为32位），通过如下步骤进行加密：</p><ol><li>Li=R(i-1)</li><li>Ri=L(i-1)⊕F(R(i-1),Ki)<br><br>DES算法一轮迭代过程：<br><br><img src="/images/DES算法一轮迭代过程.png" alt="DES算法一轮迭代过程"><br><br>F函数负责如下工作，对Ri-1通过表Ｅ进行扩展置换，置换结果(48bits)与Ki进行异或操作，然后将48bits数据分为８组，每组６bits，再通过S盒子得到32bits数据，一共有8个S盒子，每一个Ｓ盒子输入为６位输出为４位，通过P置换重新排列Ｓ盒子输出，最后将Li-1与Ｐ置换结果进行异或得到Ri。<br>E扩展置换表：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//扩展置换</span><br><span class="line">int E[]=&#123;32,1,2,3,4,5,</span><br><span class="line">                4,5,6,7,8,9,</span><br><span class="line">                8,9,10,11,12,13,</span><br><span class="line">                12,13,14,15,16,17,</span><br><span class="line">                16,17,18,19,20,21,</span><br><span class="line">                20,21,22,23,24,25,</span><br><span class="line">                24,25,26,27,28,29,</span><br><span class="line">                28,29,30,31,32,1&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>S盒子代替/选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//Ｓ盒子</span><br><span class="line">int S[][64]=&#123; &#123;14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,//S1</span><br><span class="line">                      0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,</span><br><span class="line">                      4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,</span><br><span class="line">                     15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13 &#125;,</span><br><span class="line">                    &#123;15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,//S2</span><br><span class="line">                    3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,</span><br><span class="line">                    0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,</span><br><span class="line">                    13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9&#125;,</span><br><span class="line">                    &#123;10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,//S3</span><br><span class="line">                    13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,</span><br><span class="line">                    13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,</span><br><span class="line">                    1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12&#125;,</span><br><span class="line">                    &#123;7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,//S4</span><br><span class="line">                    13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,</span><br><span class="line">                    10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,</span><br><span class="line">                    3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14&#125;,</span><br><span class="line">                    &#123;2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,//S5</span><br><span class="line">                    14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,</span><br><span class="line">                    4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,</span><br><span class="line">                    11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3&#125;,</span><br><span class="line">                    &#123;12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,//S6</span><br><span class="line">                    10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,</span><br><span class="line">                    9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,</span><br><span class="line">                    4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13&#125;,</span><br><span class="line">                    &#123;4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,//S7</span><br><span class="line">                    13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,</span><br><span class="line">                    1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,</span><br><span class="line">                    6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12&#125;,</span><br><span class="line">                    &#123;13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,//S8</span><br><span class="line">                    1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,</span><br><span class="line">                    7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,</span><br><span class="line">                    2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11&#125;</span><br><span class="line">                    &#125;;</span><br></pre></td></tr></table></figure></p><p>P置换表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//P置换表</span><br><span class="line">int P[]=&#123;16,7,20,21,</span><br><span class="line">            29,12,28,17,</span><br><span class="line">            1,15,23,26,</span><br><span class="line">            5,18,31,10,</span><br><span class="line">            2,8,24,14,</span><br><span class="line">            32,27,3,9,</span><br><span class="line">            19,13,30,6,</span><br><span class="line">            22,11,4,25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>F函数核心代码</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//ｆ函数</span><br><span class="line">int* f_func(int R[],int key[],int len)&#123;</span><br><span class="line">    //对数据有半部分进行扩展</span><br><span class="line">    int* er=repace_op(R,E,PC_2_LENGTH);</span><br><span class="line">    //扩展结果与密钥进行异或运算</span><br><span class="line">    int* xor_res=xor_op(er,len,key,len);</span><br><span class="line">    //对异或运算结果进行Ｓ盒子置换</span><br><span class="line">    int* s_box=sbox(xor_res,len);</span><br><span class="line">    //对Ｓ盒子输出结果进行Ｐ置换</span><br><span class="line">    int* res=repace_op(s_box,P,P_LENGTH);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>S盒子核心代码</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//S盒子函数</span><br><span class="line">int* sbox(int data[],int len)&#123;</span><br><span class="line">    int* res=new int[32];</span><br><span class="line">    int d=len/S_BOX_IN_LEN;</span><br><span class="line">    for(int i=0;i&lt;d;i++)&#123;</span><br><span class="line">        int offset=i*S_BOX_IN_LEN;</span><br><span class="line">        //row</span><br><span class="line">        int row=0x00;</span><br><span class="line">        row=row|data[offset];</span><br><span class="line">        row=row&lt;&lt;1;</span><br><span class="line">        row=row|data[offset+S_BOX_IN_LEN-1];</span><br><span class="line">        //column</span><br><span class="line">        int column=0x00;</span><br><span class="line">        column=column|data[offset+1];</span><br><span class="line">        column=column&lt;&lt;1;</span><br><span class="line">        column=column|data[offset+2];</span><br><span class="line">        column=column&lt;&lt;1;</span><br><span class="line">        column=column|data[offset+3];</span><br><span class="line">        column=column&lt;&lt;1;</span><br><span class="line">        column=column|data[offset+4];</span><br><span class="line">        int index=row*16+column;</span><br><span class="line">        int output=S[i][index];</span><br><span class="line">        //S盒子元素选择</span><br><span class="line">        offset=i*HALF_BITS_LENGTH;</span><br><span class="line">        //Ｓ盒子选择结果只有４位</span><br><span class="line">        int* tmp=convertToBinaryArray(output);</span><br><span class="line">        for(int j=0;j&lt;HALF_BITS_LENGTH;j++)&#123;</span><br><span class="line">            res[offset+j]=tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        //保存选择结果至res数组</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><strong>待加密数据：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int data_bin[]=&#123;0,0,0,0, 0,0,0,1, 0,0,1,0, 0,0,1,1, 0,1,0,0, 0,1,0,1, 0,1,1,0, 0,1,1,1, 1,0,0,0, 1,0,0,1, 1,0,1,0, 1,0,1,1, 1,1,0,0, 1,1,0,1, 1,1,1,0, 1,1,1,1&#125;;</span><br><span class="line">// 0123456789ABCDEF</span><br></pre></td></tr></table></figure></p><p><strong>加密密钥：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int key[]=&#123;0,0,0,1, 0,0,1,1, 0,0,1,1, 0,1,0,0, 0,1,0,1, 0,1,1,1, 0,1,1,1, 1,0,0,1, 1,0,0,1, 1,0,1,1, 1,0,1,1, 1,1,0,0, 1,1,0,1, 1,1,1,1, 1,1,1,1, 0,0,0,1&#125;;</span><br><span class="line">//133457799BBCCFF1</span><br></pre></td></tr></table></figure></p><p><img src="/images/20180515212554.png" alt="实验结果"><br><br><a href="https://github.com/ChengUU/ProgramEx/blob/master/CProgram/NS/DesEn.cpp">编码实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用最广泛的加密体制是数据加密标准(Data　Encryption Standard)，它于1972年被美国国家标准局(National Bureau of Standard, NBS)，即现在的国家标准和技术协会(National Institute of Standar
      
    
    </summary>
    
      <category term="网络安全" scheme="https://github.com/ChengUU/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="加密算法" scheme="https://github.com/ChengUU/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo写博客</title>
    <link href="https://github.com/ChengUU/2018/11/21/%E4%BD%BF%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/ChengUU/2018/11/21/使用Hexo写博客/</id>
    <published>2018-11-21T06:19:44.000Z</published>
    <updated>2025-12-08T05:26:14.420Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用hexo命令行新建md文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new Linux系统中安装JDK</span><br></pre></td></tr></table></figure></li></ol><p>命令执行结果:<br><img src="/images/20181121211956.png" alt="hexo new [layout]&lt;file&gt;"><br>hexo相关文件夹文件生成:<br><img src="/images/20181121212215.png" alt="hexo new文件生成"></p><ol start="2"><li><p>博客分类和标签设置<br><img src="/images/20181121212401.png" alt="类别和标签设置后"><br><img src="/images/20181121212453.png" alt="类别和标签编辑后"></p></li><li><p>内容添加</p><ul><li>代码块<p><img src="/images/20181121213554.png" alt="代码块"></p></li><li>图片引用<p><img src="/images/20181121213743.png" alt="图片引用"></p></li></ul></li><li><p>将相关图片添加至资源夹<br><img src="/images/20181121213933.png" alt="添加静态资源"></p></li><li><p>使用hexo清除旧的静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li><li><p>使用hexo命令生成新的页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li><li><p>使用hexo命令本地测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>使用hexo命令部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol><p>####运行效果</p><ul><li>静态页面生成命令执行:<br><img src="/images/20181121214402.png" alt="静态资源生成"></li><li>本地测试<br><img src="/images/20181121214816.png" alt="本地测试启动"></li><li>本地测试效果<br><img src="/images/20181121215401.png" alt="测试效果"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用hexo命令行新建md文件&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td cla
      
    
    </summary>
    
      <category term="Hexo" scheme="https://github.com/ChengUU/categories/Hexo/"/>
    
    
      <category term="Hexo写博客" scheme="https://github.com/ChengUU/tags/Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/ChengUU/2017/11/20/hello-world/"/>
    <id>https://github.com/ChengUU/2017/11/20/hello-world/</id>
    <published>2017-11-20T12:59:22.000Z</published>
    <updated>2025-12-08T05:29:36.840Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
