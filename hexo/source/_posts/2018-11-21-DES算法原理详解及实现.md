---
title: DES算法原理详解及实现
date: 2018-11-21 18:55:17
categories:
- 网络安全
tags:
- 加密算法
---
使用最广泛的加密体制是数据加密标准(Data　Encryption Standard)，它于1972年被美国国家标准局(National Bureau of Standard, NBS)，即现在的国家标准和技术协会(National Institute of Standard and Technology, NIST)采纳为联邦信息处理标准。DES是对称加密算法里面常见的一种，是一种使用密钥加密的块算法，密钥长度为64位(bits)，超出长度部分的密钥将会被截取丢弃。所谓对称加密，即加密和解密使用的密钥相同。对称性加密一般会按照固定长度，把待加密字符串分成块，不足一块的部分使用特殊字符填充。常见的加密模式有ECB,CBC,CTR,OFB,CFB,NCFB,NOFB。DES算法流程图如下：<br/>
![DES算法流程图](/images/DES算法流程图.png)
# DES加密
DES加密算法主要分为两部分和三个阶段，子密钥产生部分和左右数据交换部分，明文会经过如下三个阶段的处理，首先初始数据通过置换进行重新排列，然后通过相同的函数作用以及进行置换和代替处理，最后第１６轮输出的６４位数据进行左右互换，通过初始置换的逆置换得到最终的密文。
## 子密钥产生
初始密钥通过置换选择表PC1，将64位密钥减少至56位，同时将56位密钥分成C0、D0两部分，C0和D0都是28位。将C0、D0向左循环位移指定次数得到C1、D1，然后将二者进行拼接，再经过置换选择表PC2得到最终的48位子密钥。
迭代加密过程中，每一轮循环位移的次数不同(16轮)：
~~~
//循环位移次数
int DISPLACEMENT_TURNS[]={1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1};
~~~
置换选择表PC1：
~~~
//置换选择表１
int PC_1[]={57,49,41,33,25,17,9,1,
                    58,50,42,34,26,18,10,2,
                    59,51,43,35,27,19,11,3,
                    60,52,44,36,63,55,47,39,
                    31,23,15,7,62,54,46,38,
                    30,22,14,6,61,53,45,37,
                    29,21,13,5,28,20,12,4 };
~~~
置换选择表PC2：
~~~
//置换选择表２
int PC_2[]={14,17,11,24,1,5,
                    3,28,15,6,21,10,
                    23,19,12,4,26,8,
                    16,7,27,20,13,2,
                    41,52,31,37,47,55,
                    30,40,51,45,33,48,
                    44,49,39,56,34,53,
                    46,42,50,36,29,32 };
~~~
**子密钥产生核心代码**：
~~~
//子密钥产生
int* generateSubKey(int key[],int turns){
    int* subKey=new int[PC_1_LENGTH];
    if(1==turns){//第１轮
        //置换选择表PC1
        int* tmp=repace_op(key,PC_1,PC_1_LENGTH);
        //分为左右两部分
        for(int i=0;i<PC_HALF_LENGTH;i++){
            //cout<<i<<" "<<i+PC_HALF_LENGTH<<endl;
            C[i]=tmp[i];
            D[i]=tmp[i+PC_HALF_LENGTH];
            //cout<<tmp[i+PC_HALF_LENGTH]<<" "<<D[i+PC_HALF_LENGTH]<<endl;
        }
        //将左右两部分向左进行循环位移
        C=leftCycle(C,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);
        D=leftCycle(D,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);
        //将左右两部分进行拼接
        for(int i=0;i<PC_HALF_LENGTH;i++){
            subKey[i]=C[i];
            subKey[i+PC_HALF_LENGTH]=D[i];
        }
        //通过置换选择表PC2产生最终密钥
        subKey=repace_op(subKey,PC_2,PC_2_LENGTH);
    }else{
        //将Ci-1、Di-1向左进行循环位移得到Ci、Di
        C=leftCycle(C,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);
        D=leftCycle(D,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);
        //将Ci、Di进行拼接
        for(int i=0;i<PC_HALF_LENGTH;i++){
            subKey[i]=C[i];
            subKey[i+PC_HALF_LENGTH]=D[i];
        }
        //通过置换选择表PC2产生最终密钥
        subKey=repace_op(subKey,PC_2,PC_2_LENGTH);
    }
    return subKey;
}
~~~
## 进行块加密
对64位原始数据通过IP表进行重新排列，将重新排列的数据分为左右两部分L、R（二者均为32位），通过如下步骤进行加密：
1. Li=R(i-1)
2. Ri=L(i-1)⊕F(R(i-1),Ki)<br/>
DES算法一轮迭代过程：<br/>
![DES算法一轮迭代过程](/images/DES算法一轮迭代过程.png)<br/>
F函数负责如下工作，对Ri-1通过表Ｅ进行扩展置换，置换结果(48bits)与Ki进行异或操作，然后将48bits数据分为８组，每组６bits，再通过S盒子得到32bits数据，一共有8个S盒子，每一个Ｓ盒子输入为６位输出为４位，通过P置换重新排列Ｓ盒子输出，最后将Li-1与Ｐ置换结果进行异或得到Ri。
E扩展置换表：
~~~
//扩展置换
int E[]={32,1,2,3,4,5,
                4,5,6,7,8,9,
                8,9,10,11,12,13,
                12,13,14,15,16,17,
                16,17,18,19,20,21,
                20,21,22,23,24,25,
                24,25,26,27,28,29,
                28,29,30,31,32,1};
~~~
S盒子代替/选择：
~~~
//Ｓ盒子
int S[][64]={ {14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,//S1
                      0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,
                      4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,
                     15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13 },
                    {15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,//S2
                    3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,
                    0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,
                    13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9},
                    {10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,//S3
                    13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,
                    13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,
                    1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12},
                    {7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,//S4
                    13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,
                    10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,
                    3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14},
                    {2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,//S5
                    14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,
                    4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,
                    11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3},
                    {12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,//S6
                    10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,
                    9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,
                    4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13},
                    {4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,//S7
                    13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,
                    1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,
                    6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12},
                    {13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,//S8
                    1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,
                    7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,
                    2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}
                    };
~~~
P置换表：
~~~
//P置换表
int P[]={16,7,20,21,
            29,12,28,17,
            1,15,23,26,
            5,18,31,10,
            2,8,24,14,
            32,27,3,9,
            19,13,30,6,
            22,11,4,25
};
~~~
**F函数核心代码**：
~~~
//ｆ函数
int* f_func(int R[],int key[],int len){
    //对数据有半部分进行扩展
    int* er=repace_op(R,E,PC_2_LENGTH);
    //扩展结果与密钥进行异或运算
    int* xor_res=xor_op(er,len,key,len);
    //对异或运算结果进行Ｓ盒子置换
    int* s_box=sbox(xor_res,len);
    //对Ｓ盒子输出结果进行Ｐ置换
    int* res=repace_op(s_box,P,P_LENGTH);
    return res;
}
~~~
**S盒子核心代码**：
~~~
//S盒子函数
int* sbox(int data[],int len){
    int* res=new int[32];
    int d=len/S_BOX_IN_LEN;
    for(int i=0;i<d;i++){
        int offset=i*S_BOX_IN_LEN;
        //row
        int row=0x00;
        row=row|data[offset];
        row=row<<1;
        row=row|data[offset+S_BOX_IN_LEN-1];
        //column
        int column=0x00;
        column=column|data[offset+1];
        column=column<<1;
        column=column|data[offset+2];
        column=column<<1;
        column=column|data[offset+3];
        column=column<<1;
        column=column|data[offset+4];
        int index=row*16+column;
        int output=S[i][index];
        //S盒子元素选择
        offset=i*HALF_BITS_LENGTH;
        //Ｓ盒子选择结果只有４位
        int* tmp=convertToBinaryArray(output);
        for(int j=0;j<HALF_BITS_LENGTH;j++){
            res[offset+j]=tmp[j];
        }
        //保存选择结果至res数组
    }
    return res;
}
~~~
## 实验结果
**待加密数据：**
~~~
int data_bin[]={0,0,0,0, 0,0,0,1, 0,0,1,0, 0,0,1,1, 0,1,0,0, 0,1,0,1, 0,1,1,0, 0,1,1,1, 1,0,0,0, 1,0,0,1, 1,0,1,0, 1,0,1,1, 1,1,0,0, 1,1,0,1, 1,1,1,0, 1,1,1,1};
// 0123456789ABCDEF
~~~
**加密密钥：**
~~~
int key[]={0,0,0,1, 0,0,1,1, 0,0,1,1, 0,1,0,0, 0,1,0,1, 0,1,1,1, 0,1,1,1, 1,0,0,1, 1,0,0,1, 1,0,1,1, 1,0,1,1, 1,1,0,0, 1,1,0,1, 1,1,1,1, 1,1,1,1, 0,0,0,1};
//133457799BBCCFF1
~~~
![实验结果](/images/20180515212554.png)<br>
[编码实现](https://github.com/ChengUU/ProgramEx/blob/master/CProgram/NS/DesEn.cpp)
